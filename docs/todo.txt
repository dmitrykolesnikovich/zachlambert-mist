----- Current Thoughts -----
Rough outline of the current state of the project and what
I'm working on.

Purpose of resources, scene, renderer
- Resources: Handles the resources required for rendering, including
    shaders, textures/materials and meshes/models.
- Scene: Handles all the information necessary for defining a scene
    to be rendered, including the camera, lights, and entities, which
    make use of resources.
- Renderer: Take the scene information and render it. No rendering
    logic should be included outside this directory. Other classes should
    only contain the necessary information for rendering.


----- Ideal api usage -----
Ideas about what an ideal api would be (in terms of ease of use), to help
figure out how to design the api.

int main()
{
    Window window; // Sensible defaults
    window.set_size(720, 480); // Can edit attributes afterwards
    window.create(); // May need, dependent on how the window is implemented


    ModelManager model_manager;

    model_manager.create_model_from_file("frog", "animals/frog.obj");

    ModelConfig my_sphere_config;
    my_sphere_config.set_type(ModelType::SPHERE);
    my_sphere_config.set_attribute("radius", 10); // Only applicable for certain types
    my_sphere_config.set_material("matte");
    my_sphere_config.set_color("red"); // Only applicable for certain materials
    model_manager.create_model_from_config("my_sphere", my_sphere_config);

    Scene scene;

    // Best way to create entities:
    // Get a pointer/reference from the scene, to allow manipulation of
    // the entity stored in the scene
    // Option 1: Use a pointer
    Entity *frog = scene.create_entity("frog");
    frog->set_model("frog");
    // Can do this:
    *frog = Entity(...) // which we don't want
    // Option 2: Use a reference
    Entity &frog = scene.create_entity("frog");
    frog.set_model("frog");
    // But, allow the user to mistakenly do:
    Entity frog = scene.create_entity("frog");
    frog.set_model("frog"); // Not making any changes, editing a local object
    // Option 3: Create a handle object
    struct EntityData {
        std::string model;
        ...
    }
    class Entity{
        EntityData *data;
    public:
        void set_model(std::string model) { data->model = model; }
        ...
    }
    Entity entity = scene.create_entity("frog");


    Entity sphere;
    sphere.set_model("my_sphere");
    sphere.set_position(Vector3(2, 2, 2));

    Scene scene;
    scene.add_entity("frog", frog);
    scene.add_entity("sphere", sphere);

    Renderer renderer;
    renderer.set_model_manager(&model_manager);
    renderer.set_scene(&scene);

    Clock clock;

    while (window.is_running()) {
        float dt = clock.tick();
    }

    return 0;
}
